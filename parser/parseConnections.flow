version 0.1

flow ParseConnections {
  [ParserData]-> connections(ParseMulti1) -> ;
  connections() semOut [ParserData]-> semantic(SemanticCreateChain) -> semIn connections() ;

  connections() subOut [ParserData]-> chain(ParseAll) -> subIn connections() ;

  chain() subOut.0 [ParserData]-> chainBeg(ParseChainBegin) -> subIn chain() ;
  chain() subOut.1 [ParserData]-> chainMids(ParseMulti0) -> subIn chain() ;
  chain() subOut.2 [ParserData]-> optChainEnd(ParseOptional) -> subIn chain() ;
  chain() subOut.3 [ParserData]-> stmtEnd(ParseStatementEnd) -> subIn chain() ;

  chainMids() subOut [ParserData]-> chainMid(ParseChainMiddle) -> subIn chainMids() ;

  optChainEnd() subOut [ParserData]-> chainEnd(ParseChainEnd) -> subIn optChainEnd() ;
}

// semantic result: { (conn data.Connection{FromPort, DataType, ShowDataType, ToPort, ToOp}?), (oper data.Operation{Name, Type, SrcPos, OutPorts}) }
flow ParseChainBegin {
  [ParserData]-> chainBeg(ParseAlternatives) -> ;

  chainBeg() subOut.0 [ParserData]-> chainBegMax(ParseAll) -> subIn chainBeg() ;
  chainBeg() subOut.1 [ParserData]-> chainBegMin(ParseAll) -> subIn chainBeg() ;

  chainBegMax() semOut [ParserData]-> maxSemantic(SemanticChainBeginMax) -> semIn chainBegMax() ;
  chainBegMax() subOut.0 [ParserData]-> optPortMax(ParseOptPort) -> subIn chainBegMax() ;
  chainBegMax() subOut.1 [ParserData]-> chainMid(ParseChainMiddle) -> subIn chainBegMax() ;

  chainBegMin() semOut [ParserData]-> minSemantic(SemanticChainBeginMin) -> semIn chainBegMin() ;
  chainBegMin() subOut.0 [ParserData]-> opNameParens(ParseOperationNameParens) -> subIn chainBegMin() ;
  chainBegMin() subOut.1 [ParserData]-> optPortMin(ParseOptPort) -> subIn chainBegMin() ;
}

// semantic result: { (bigIdentDataType string), (op data.Operation{Name, Type, SrcPos, InPorts, OutPorts}) }
flow ParseChainMiddle {
  [ParserData]-> chainMid(ParseAll) -> ;
  chainMid() semOut [ParserData]-> semantic(SemanticCreateChainMiddle) -> semIn chainMid() ;

  chainMid() subOut.0 [ParserData]-> arrow(ParseArrow) -> subIn chainMid() ;
  chainMid() subOut.1 [ParserData]-> connPart(ParseConnectionPart) -> subIn chainMid() ;
}

// semantic result: connection data.Connection{FromPort, DataType, ToPort}
flow ParseChainEnd {
  [ParserData]-> chainEnd(ParseAll) -> ;
  chainEnd() semOut [ParserData]-> semantic(SemanticCreateChainEnd) -> semIn chainEnd() ;

  chainEnd() subOut.0 [ParserData]-> arrow(ParseArrow) -> subIn chainEnd() ;
  chainEnd() subOut.1 [ParserData]-> optPort(ParseOptPort) -> subIn chainEnd() ;
}
