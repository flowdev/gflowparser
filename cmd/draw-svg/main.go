package main

import (
	"fmt"
	"log"
	"os"
	"text/template"
)

const (
	blue  = "rgb(96,196,255)"
	green = "rgb(32,224,32)"
)

const svgDiagram = `<?xml version="1.0" ?>
<svg version="1.1" xmlns="http://www.w3.org/2000/svg" width="{{.TotalWidth}}px" height="{{.TotalHeight}}px">
<!-- Generated by simple FlowDev draw-svg tool. -->
	<rect fill="rgb(255,255,255)" fill-opacity="1" stroke="none" stroke-opacity="1" stroke-width="0.0" width="{{.TotalWidth}}" height="{{.TotalHeight}}" x="0" y="0"/>
{{- range .Arrows}}
	<line stroke="rgb(0,0,0)" stroke-opacity="1.0" stroke-width="2.5" x1="{{.X1}}" y1="{{.Y1}}" x2="{{.X2}}" y2="{{.Y2}}"/>
	<line stroke="rgb(0,0,0)" stroke-opacity="1.0" stroke-width="2.5" x1="{{.XTip1}}" y1="{{.YTip1}}" x2="{{.X2}}" y2="{{.Y2}}"/>
	<line stroke="rgb(0,0,0)" stroke-opacity="1.0" stroke-width="2.5" x1="{{.XTip2}}" y1="{{.YTip2}}" x2="{{.X2}}" y2="{{.Y2}}"/>
{{end}}
{{- range .Rects}}
	<rect fill="{{.Color}}" fill-opacity="1.0" stroke="rgb(0,0,0)" stroke-opacity="1.0" stroke-width="2.5" width="{{.Width}}" height="{{.Height}}" x="{{.X}}" y="{{.Y}}" rx="10" ry="10"/>
{{- end}}

{{range .Texts}}
	<text fill="rgb(0,0,0)" fill-opacity="1.0" font-family="monospace" font-size="16" x="{{.X}}" y="{{.Y}}" textLength="{{.Width}}" lengthAdjust="spacingAndGlyphs">{{.Text}}</text>
{{- end}}
</svg>
`

type svgArrow struct {
	X1, Y1       int
	X2, Y2       int
	XTip1, YTip1 int
	XTip2, YTip2 int
}

type svgRect struct {
	X, Y   int
	Width  int
	Height int
	Color  string
}

type svgText struct {
	X, Y  int
	Width int
	Text  string
}

type svgFlow struct {
	TotalWidth  int
	TotalHeight int
	Arrows      []*svgArrow
	Rects       []*svgRect
	Texts       []*svgText
}

type arrow struct {
	dataType string
	hasSrcOp bool
	srcPort  string
	hasDstOp bool
	dstPort  string
}

type rect struct {
	width  int
	height int
	isFill bool
	text   []string
}

type flow struct {
	shapes []interface{}
}

func flowDataToSVG(f *flow) *svgFlow {
	sas := make([]*svgArrow, 0, len(f.shapes))
	srs := make([]*svgRect, 0, len(f.shapes))
	sts := make([]*svgText, 0, 64)
	x0 := 2 // don't start directly at the edge
	y0 := 0 // the shapes leave head room themself
	var y, ymax int

	for _, is := range f.shapes {
		switch s := is.(type) {
		case *arrow:
			sas, sts, x0, y = arrowDataToSVG(s, sas, sts, x0, y0)
		case *rect:
			srs, sts, x0, y = rectDataToSVG(s, srs, sts, x0, y0)
		default:
			panic(fmt.Sprintf("unsupported type: %T", is))
		}
		ymax = max(ymax, y)
	}
	return &svgFlow{
		TotalWidth: x0 + 2, TotalHeight: ymax,
		Arrows: sas, Rects: srs, Texts: sts,
	}
}
func arrowDataToSVG(
	a *arrow,
	sas []*svgArrow,
	sts []*svgText,
	x0, y0 int,
) ([]*svgArrow, []*svgText, int, int) {
	x := x0
	y := y0 + 24
	portLen := 0 // length in chars NOT pixels

	sts, x, portLen = addSrcPort(a, sts, x, y)

	if a.hasDstOp {
		portLen += len(a.dstPort)
	}
	width := max(
		portLen+1,
		len(a.dataType)+2,
	)*12 + 6 + // 6 so the source port text isn't glued to the op
		12 // last 12 is for tip of arrow

	if a.dataType != "" {
		sts = append(sts, &svgText{
			X: x + ((width-12)-len(a.dataType)*12)/2, Y: y - 8,
			Width: len(a.dataType) * 12,
			Text:  a.dataType,
		})
	}

	sas = append(sas, &svgArrow{
		X1: x, Y1: y,
		X2: x + width, Y2: y,
		XTip1: x + width - 8, YTip1: y - 8,
		XTip2: x + width - 8, YTip2: y + 8,
	})
	x += width

	sts, x = addDstPort(a, sts, x, y)

	return sas, sts, x, y + 36
}
func addSrcPort(a *arrow, sts []*svgText, x, y int) ([]*svgText, int, int) {
	portLen := 0
	if !a.hasSrcOp { // text before the arrow
		if a.srcPort != "" {
			sts = append(sts, &svgText{
				X: x + 1, Y: y + 6,
				Width: len(a.srcPort)*12 - 2,
				Text:  a.srcPort,
			})
		}
		x += 12 * len(a.srcPort)
	} else { // text under the arrow
		portLen += len(a.srcPort)
		if a.srcPort != "" {
			sts = append(sts, &svgText{
				X: x + 6, Y: y + 20,
				Width: len(a.srcPort) * 12,
				Text:  a.srcPort,
			})
		}
	}
	return sts, x, portLen
}
func addDstPort(a *arrow, sts []*svgText, x, y int) ([]*svgText, int) {
	if !a.hasDstOp {
		if a.dstPort != "" { // text after the arrow
			sts = append(sts, &svgText{
				X: x + 1, Y: y + 6,
				Width: len(a.dstPort)*12 - 2,
				Text:  a.dstPort,
			})
		}
		x += 12 * len(a.dstPort)
	} else if a.dstPort != "" { // text under the arrow
		sts = append(sts, &svgText{
			X: x - len(a.dstPort)*12 - 12, Y: y + 20,
			Width: len(a.dstPort) * 12,
			Text:  a.dstPort,
		})
	}
	return sts, x
}

func rectDataToSVG(r *rect, srs []*svgRect, sts []*svgText, x0, y0 int) ([]*svgRect, []*svgText, int, int) {
	x := x0
	y := y0 + 6
	w := maxLen(r.text)*12 + 12*2
	h := len(r.text)*24 + 6*2

	srs = append(srs, &svgRect{
		X: x, Y: y,
		Width:  w,
		Height: h,
		Color:  blue,
	})

	y += 6
	for _, t := range r.text {
		sts = append(sts, &svgText{
			X: x + 12, Y: y + 24 - 6,
			Width: len(t) * 12,
			Text:  t,
		})
		y += 24
	}

	return srs, sts, x + w, y + 6 + 6 // y + padding + margin
}

func main() {
	flow := &flow{
		shapes: []interface{}{
			&arrow{
				dataType: "",
				hasSrcOp: false, srcPort: "in",
				hasDstOp: true, dstPort: "",
			},
			&rect{
				isFill: false,
				text:   []string{"do"},
			},
			&arrow{
				dataType: "Data",
				hasSrcOp: true, srcPort: "out",
				hasDstOp: true, dstPort: "in",
			},
			&rect{
				isFill: true,
				text:   []string{"ra"},
			},
		},
	}
	svgflow := flowDataToSVG(flow)

	// compile and execute template
	t := template.Must(template.New("diagram").Parse(svgDiagram))
	err := t.Execute(os.Stdout, svgflow)
	if err != nil {
		log.Println("executing template:", err)
	}
}

func maxLen(ss []string) int {
	m := 0
	for _, s := range ss {
		m = max(m, len(s))
	}
	return m
}
func max(a, b int) int {
	if a >= b {
		return a
	}
	return b
}
